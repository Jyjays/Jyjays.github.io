<!DOCTYPE html><html lang="zh_TW" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Project 3 Query Execution | Jyjays's Blog</title><meta name="author" content="Jyjays"><meta name="copyright" content="Jyjays"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Task #2UML class.pdf aggregation executor聚合函数执行器，该executor只有一个child executor。  Init函数从child executor中获取到要聚合的键和值，并利用InsertCombine函数计算聚合结果，插入到哈希表中 （lab中使用的是unordered_map简单处理)。 Next函数则遍历哈希表中所有的键值对，将其输出到元">
<meta property="og:type" content="article">
<meta property="og:title" content="Project 3 Query Execution">
<meta property="og:url" content="https://jyjays.github.io/2025/02/21/Project%203%20Query%20Execution/Project%203%20Query%20Execution/index.html">
<meta property="og:site_name" content="Jyjays&#39;s Blog">
<meta property="og:description" content="Task #2UML class.pdf aggregation executor聚合函数执行器，该executor只有一个child executor。  Init函数从child executor中获取到要聚合的键和值，并利用InsertCombine函数计算聚合结果，插入到哈希表中 （lab中使用的是unordered_map简单处理)。 Next函数则遍历哈希表中所有的键值对，将其输出到元">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://s2.loli.net/2025/02/15/fuHwdPDZ8cNslFC.png">
<meta property="article:published_time" content="2025-02-20T23:55:00.000Z">
<meta property="article:modified_time" content="2025-02-20T07:56:48.255Z">
<meta property="article:author" content="Jyjays">
<meta property="article:tag" content="Database">
<meta property="article:tag" content="CMU 15-445">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2025/02/15/fuHwdPDZ8cNslFC.png"><link rel="shortcut icon" href="https://s2.loli.net/2025/02/15/Yhj9w85grSxptQT.jpg"><link rel="canonical" href="https://jyjays.github.io/2025/02/21/Project%203%20Query%20Execution/Project%203%20Query%20Execution/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Project 3 Query Execution',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-02-19 23:56:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2025/02/15/Yhj9w85grSxptQT.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2025/02/15/fuHwdPDZ8cNslFC.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Jyjays's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Project 3 Query Execution</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-02-20T23:55:00.000Z" title="Created 2025-02-20 15:55:00">2025-02-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-02-20T07:56:48.255Z" title="Updated 2025-02-19 23:56:48">2025-02-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CMU-15-445/">CMU 15-445</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Project 3 Query Execution"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Task-2"><a href="#Task-2" class="headerlink" title="Task #2"></a>Task #2</h1><p><a href="assets/UML%20class-20250220155501-kemksmp.pdf">UML class.pdf</a></p>
<h2 id="aggregation-executor"><a href="#aggregation-executor" class="headerlink" title="aggregation executor"></a>aggregation executor</h2><p>聚合函数执行器，该executor只有一个child executor。</p>
<hr>
<p>Init函数从child executor中获取到要聚合的键和值，并利用InsertCombine函数计算聚合结果，插入到哈希表中 <em>（lab中使用的是unordered_map简单处理)。</em></p>
<p>Next函数则遍历哈希表中所有的键值对，将其输出到元组中。</p>
<hr>
<p>Init和Next函数的实现还是比较简单的，这个task的主要内容就在于哈希表类中<code>CombineAggregateValues</code>​函数的实现。需要完成对五种聚合函数的计算。</p>
<p>需要注意的是不同情况下聚合函数值的初始化：count函数初始化为Interger(0)，其它的情况初始化为NULL。</p>
<p>难点还是语法上的困难吧，需要使用lab提供的ValueFactory，一开始可能有无从下手的感觉，理清执行流程就好了。</p>
<h2 id="nested-loop-join-executor"><a href="#nested-loop-join-executor" class="headerlink" title="nested loop join executor"></a>nested loop join executor</h2><p>该运算符的输出模式是左表的所有列，然后是右表的所有列。</p>
<p>利用嵌套循环实现 inner join 和 left join 。</p>
<blockquote>
<p>嵌套循环：外循环和内循环，对应外表和内表。相当于从笛卡尔积中进行筛选。</p>
</blockquote>
<blockquote>
<p><strong>Hint:</strong>  You should use the predicate in the <code>NestedLoopJoinPlanNode</code>​. See <code>AbstractExpression::EvaluateJoin</code>​, which handles the left tuple and right tuple and their respective schemas. Note that this returns a <code>Value</code>​, which could be false, true, or NULL. See <code>FilterExecutor</code>​ for how to apply predicates on tuples.</p>
</blockquote>
<p>The output schema of this operator is all columns from the left table followed by all columns from the right table.</p>
<hr>
<p>left表中的一个值可能会对应right表中的多个值，所以整个嵌套循环并不是简单的找到符合条件的值就将right表初始化，而是两个表都应该遍历完。</p>
<p>​<img src="https://s2.loli.net/2025/02/16/t1JvFONkrmas6el.png" alt="image">​</p>
<hr>
<p>这个executor最关键的两个点就是：</p>
<ol>
<li>对于每个左值，保证遍历所有的右值，以找到所有符合条件的记录。</li>
<li>如果左值没有匹配的值，且是 left join 的情况下，按照右值的格式和类型匹配对应的空值。</li>
</ol>
<p>实现时应该添加几个状态相关的私有成员和左值，因为一个左值可能有多个匹配的右值，这样下一次调用Next函数时可以接着上一次的进度继续遍历。</p>
<hr>
<p>该exexutor还会暴露之前写的executor的bug，因为它会多次调用子executor的Init()函数，所以之前如果有Init()只分配内存而未释放的情况，就会导致结果错误，甚至是CPU100%。</p>
<h1 id="Task-3"><a href="#Task-3" class="headerlink" title="Task #3"></a>Task #3</h1><h2 id="Hash-Join-Executor"><a href="#Hash-Join-Executor" class="headerlink" title="Hash Join Executor"></a>Hash Join Executor</h2><hr>
<h3 id="Hash-Join-algorithm"><a href="#Hash-Join-algorithm" class="headerlink" title="Hash Join algorithm"></a>Hash Join algorithm</h3><p>哈希连接算法的思想是使用哈希表根据元组的 join 属性将元组拆分为更小的块。</p>
<blockquote>
<p>If tuple r ∈ R and a tuple s ∈ S satisfy the join condition, then they have the same value for the join attributes. If that value is hashed to some value i, the R tuple has to be in bucket r(i), and the S tuple has to be in bucket s(i). Thus, the R tuples in bucket r(i) need only to be compared with the S tuples in bucket s(i).</p>
</blockquote>
<blockquote>
<p>Hash joins can only be used for equi-joins on the complete join key.</p>
</blockquote>
<p>如何理解 complete join key?</p>
<p>“Complete join key” 的意思是，如果连接键由多个列构成（即复合键），那么用于连接的条件必须涵盖这个复合键中的所有列，而不能只使用其中的一部分。也就是说，Hash Join 只适用于连接条件中每个参与连接的行都需要满足完整的等值比较。例如，如果两个表以 (A, B) 作为连接键，那么连接条件必须同时包含 A = A’ 和 B = B’ 两个条件，才能认为使用了“complete join key”。这种要求确保了对连接键计算的哈希值是一致且唯一的，从而保证了哈希连接算法能正确地将两个表的数据匹配起来。</p>
<p>‍</p>
<h3 id="Basic-Hash-Join"><a href="#Basic-Hash-Join" class="headerlink" title="Basic Hash Join"></a>Basic Hash Join</h3><p>可以分为两个阶段：<br><strong>Phase</strong> #1</p>
<p>扫描 outer relation（数据较少的那个表）,利用哈希函数将连接属性映射到bucket中</p>
<p><strong>phase #2</strong></p>
<p>扫描 inner relation，并利用哈希函数找到bucket中与之对应的位置的值，与匹配的tuple进行连接。由于哈希表中可能存在冲突，因此 DBMS 需要检查 join 属性的原始值，以确定 Tuples 是否真正匹配。</p>
<p>‍</p>
<p>如果 DBMS 知道外部表的大小，则联接可以使用静态哈希表。如果它不知道大小，则 join 必须使用动态哈希表或允许溢出页面。</p>
<p>进一步优化的话可以采取<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bloom_filter">布隆过滤器</a>实现，来减少一定不会匹配的值访问磁盘带来的开支。</p>
<h3 id="Grace-Hash-Join-Partitioned-Hash-Join"><a href="#Grace-Hash-Join-Partitioned-Hash-Join" class="headerlink" title="Grace Hash Join &#x2F; Partitioned Hash Join"></a>Grace Hash Join &#x2F; Partitioned Hash Join</h3><blockquote>
<p>When the tables do not fit on main memory, the DBMS has to swap tables in and out essentially at random, which leads to poor performance. The Grace Hash Join is an extension of the basic hash join that also hashes the inner table into partitions that are written out to disk.</p>
</blockquote>
<p><strong>Phase #1</strong></p>
<p>Build: First, scan both the outer and inner tables and populate a hash table using the hash function h1 on the join attributes. The hash table’s buckets are written out to disk as needed. If a single bucket does not fit in memory, the DBMS can use recursive partitioning with different hash function h2 (where h1 is not equal with h2) to further divide the bucket. This can continue recursively until the buckets fit into memory.</p>
<p> <strong>•Phase #2</strong></p>
<p>Probe: For each bucket level, retrieve the corresponding pages for both outer and inner tables. Then, perform a nested loop join on the tuples in those two pages. The pages will fit in memory, so this join operation will be fast.</p>
<p>‍</p>
<h3 id="Implement"><a href="#Implement" class="headerlink" title="Implement"></a>Implement</h3><p>因为lab只要求实现inner join和left join，所以流水线应该靠左值驱动，在Init函数中初始化哈希表时应该用右表进行初始化，然后在Next函数中按照左值的顺序返回对应的元组。</p>
<hr>
<h2 id="Hash-Join-Optimizer"><a href="#Hash-Join-Optimizer" class="headerlink" title="Hash Join Optimizer"></a>Hash Join Optimizer</h2><p>​<img src="https://s2.loli.net/2025/02/18/FWqthzu4oT5jmvR.png" alt="image">​</p>
<p>需要注意的点是把所有的child plan递归地优化，并且要处理比较表达式和逻辑表达式。如果是比较表达式就将两侧的ColumnValueExpression添加到左右vector中，如果是逻辑表达式就接着对左右child plan进行递归处理。</p>
<h1 id="Task-4"><a href="#Task-4" class="headerlink" title="Task #4"></a>Task #4</h1><h2 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h2><p>​<img src="https://s2.loli.net/2025/02/18/yKoxPM7BdgRkCUl.png" alt="image">​</p>
<h3 id="如何实现-Top-N-Sort"><a href="#如何实现-Top-N-Sort" class="headerlink" title="如何实现 Top-N Sort"></a><strong>如何实现 Top-N Sort</strong></h3><p>在 <code>ORDER BY ... LIMIT N</code>​ 的情况下，我们不需要对整个数据集进行完整排序，而是可以 <strong>使用一个大小为 N 的最小堆（Min-Heap）</strong>  来高效获取前 N 个元素。具体实现如下：</p>
<h4 id="1-算法思想"><a href="#1-算法思想" class="headerlink" title="1. 算法思想"></a><strong>1. 算法思想</strong></h4><ul>
<li><p><strong>扫描数据</strong>：顺序扫描输入数据，每次读取一个新的元组。</p>
</li>
<li><p><strong>维护一个大小为 N 的最小堆（Min-Heap）</strong> ：</p>
<ul>
<li><p>如果堆的大小小于 N，直接插入新元素。</p>
</li>
<li><p>如果堆的大小已经是 N，检查当前元素是否比堆顶元素更大：</p>
<ul>
<li><strong>是</strong> → 替换堆顶（移除最小值），插入新的较大值。</li>
<li><strong>否</strong> → 忽略当前元素（因为它不会进入前 N）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>最终堆中存储的是前 N 个最大的元素</strong>。</p>
</li>
<li><p><strong>最后对堆中的 N 个元素执行一次排序（O(N log N））</strong> ，得到最终的 Top-N 结果。</p>
</li>
</ul>
<h2 id="Window-Function"><a href="#Window-Function" class="headerlink" title="Window Function"></a>Window Function</h2><blockquote>
<p>Split the data based on the conditions in the partition by clause. The window function is computed on the tuples in each frame, and we output what we have computed in each frame.</p>
</blockquote>
<p>这个executor就是sort + aggregation的结合体，加了个RANK类型，用分区的expression作key，然后在插入key value时将tuple对应的聚合函数值计算出来，最后统一提取出来，放到一块。怪麻烦的。。。</p>
<h1 id="Optimizer-和-Executor-的区别"><a href="#Optimizer-和-Executor-的区别" class="headerlink" title="Optimizer 和 Executor 的区别"></a>Optimizer 和 Executor 的区别</h1><p>在数据库系统中，优化器（Optimizer）和执行器（Executor）的职责和思路有本质区别。以 <code>OptimizeSeqScanAsIndexScan</code>​ 优化器代码和 <code>AggregationExecutor</code>​ 代码为例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Optimizer::OptimizeSeqScanAsIndexScan</span><span class="params">(<span class="type">const</span> bustub::AbstractPlanNodeRef &amp;plan)</span> -&gt; AbstractPlanNodeRef </span>&#123;</span><br><span class="line">  <span class="comment">// TODO(student): implement seq scan with predicate -&gt; index scan optimizer rule</span></span><br><span class="line">  <span class="comment">// The Filter Predicate Pushdown has been enabled for you in optimizer.cpp when forcing starter rule</span></span><br><span class="line">  std::vector&lt;AbstractPlanNodeRef&gt; children;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;child : plan-&gt;<span class="built_in">GetChildren</span>()) &#123;</span><br><span class="line">    children.<span class="built_in">emplace_back</span>(<span class="built_in">OptimizeSeqScanAsIndexScan</span>(child));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> optimized_plan = plan-&gt;<span class="built_in">CloneWithChildren</span>(children);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (optimized_plan-&gt;<span class="built_in">GetType</span>() == PlanType::SeqScan) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> &amp;seq_plan = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> SeqScanPlanNode &amp;&gt;(*optimized_plan);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> filter = seq_plan.filter_predicate_; filter != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="type">const</span> <span class="keyword">auto</span> *expr = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> ComparisonExpression *&gt;(filter.<span class="built_in">get</span>()); expr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (expr-&gt;comp_type_ == ComparisonType::Equal) &#123;</span><br><span class="line">          <span class="comment">// Get the index_oid and the pred_key</span></span><br><span class="line">          <span class="keyword">auto</span> table_info = catalog_.<span class="built_in">GetTable</span>(seq_plan.<span class="built_in">GetTableOid</span>());</span><br><span class="line">          <span class="keyword">auto</span> indices = catalog_.<span class="built_in">GetTableIndexes</span>(table_info-&gt;name_);</span><br><span class="line">          <span class="type">const</span> <span class="keyword">auto</span> *left_expr = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> ColumnValueExpression *&gt;(expr-&gt;children_[<span class="number">0</span>].<span class="built_in">get</span>());</span><br><span class="line">          <span class="keyword">auto</span> right_expr = <span class="built_in">dynamic_cast</span>&lt;ConstantValueExpression *&gt;(expr-&gt;children_[<span class="number">1</span>].<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">          <span class="built_in">BUSTUB_ASSERT</span>(left_expr != <span class="literal">nullptr</span>, <span class="string">&quot;left_expr = nullptr! (From seqscan_as_indexscan)&quot;</span>);</span><br><span class="line">          <span class="built_in">BUSTUB_ASSERT</span>(right_expr != <span class="literal">nullptr</span>, <span class="string">&quot;right_expr = nullptr! (From seqscan_as_indexscan)&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;index : indices) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> &amp;columns = index-&gt;index_-&gt;<span class="built_in">GetKeyAttrs</span>();</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> &amp;match_column_id = left_expr-&gt;<span class="built_in">GetColIdx</span>();</span><br><span class="line">            <span class="keyword">if</span> (columns.<span class="built_in">size</span>() == <span class="number">1</span> &amp;&amp; columns[<span class="number">0</span>] == match_column_id) &#123;</span><br><span class="line">              <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;IndexScanPlanNode&gt;(seq_plan.output_schema_, table_info-&gt;oid_, index-&gt;index_oid_,</span><br><span class="line">                                                         filter,right_expr);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> plan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AggregationExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化子执行器（例如开始扫描表）</span></span><br><span class="line">  child_executor_-&gt;<span class="built_in">Init</span>();</span><br><span class="line"></span><br><span class="line">  Tuple tuple_ = &#123;&#125;;</span><br><span class="line">  RID rid_ = <span class="built_in">RID</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历子执行器的所有输入元组</span></span><br><span class="line">  <span class="keyword">while</span> (child_executor_-&gt;<span class="built_in">Next</span>(&amp;tuple_, &amp;rid_)) &#123;</span><br><span class="line">    <span class="comment">// 提取 GROUP BY 的键（例如 group by id）和待聚合的值（例如 sum(age)）</span></span><br><span class="line">    <span class="keyword">auto</span> key = <span class="built_in">MakeAggregateKey</span>(&amp;tuple_);</span><br><span class="line">    <span class="keyword">auto</span> value = <span class="built_in">MakeAggregateValue</span>(&amp;tuple_);</span><br><span class="line">    <span class="comment">// 将键值对插入哈希表，合并相同键的聚合值（例如累加 SUM）</span></span><br><span class="line">    aht_.<span class="built_in">InsertCombine</span>(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理特殊情况：无 GROUP BY 且无输入数据时（例如 SELECT COUNT(*) FROM empty_table）</span></span><br><span class="line">  <span class="keyword">if</span> (aht_.<span class="built_in">Begin</span>() == aht_.<span class="built_in">End</span>() &amp;&amp; <span class="built_in">GetOutputSchema</span>().<span class="built_in">GetColumnCount</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">    aht_.<span class="built_in">InsertEmptyCombine</span>();  <span class="comment">// 插入一个空聚合结果（例如 COUNT(*) 返回 0）</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重置迭代器到哈希表起始位置</span></span><br><span class="line">  aht_iterator_ = aht_.<span class="built_in">Begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">AggregationExecutor::Next</span><span class="params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  std::vector&lt;Value&gt; values&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历哈希表中的所有键值对</span></span><br><span class="line">  <span class="keyword">if</span> (aht_iterator_ == aht_.<span class="built_in">End</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 遍历完成，返回 false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提取当前迭代器指向的键和聚合值</span></span><br><span class="line">  <span class="keyword">auto</span> key = aht_iterator_.<span class="built_in">Key</span>().group_bys_;     <span class="comment">// GROUP BY 的键（例如 id=1）</span></span><br><span class="line">  <span class="keyword">auto</span> value = aht_iterator_.<span class="built_in">Val</span>().aggregates_;  <span class="comment">// 聚合结果（例如 SUM(age)=30）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将键和聚合值合并为输出元组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;key_val : key) &#123;</span><br><span class="line">    values.<span class="built_in">emplace_back</span>(key_val);  <span class="comment">// 添加 GROUP BY 列的值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;val : value) &#123;</span><br><span class="line">    values.<span class="built_in">emplace_back</span>(val);  <span class="comment">// 添加聚合结果的值</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成输出元组</span></span><br><span class="line">  *tuple = <span class="built_in">Tuple</span>(values, &amp;<span class="built_in">GetOutputSchema</span>());</span><br><span class="line">  ++aht_iterator_;  <span class="comment">// 移动到下一个键值对</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 成功返回一个元组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以总结二者的核心差异如下：</p>
<hr>
<h3 id="1-目标不同"><a href="#1-目标不同" class="headerlink" title="1. 目标不同"></a>1. 目标不同</h3><table>
<thead>
<tr>
<th>组件</th>
<th>核心目标</th>
</tr>
</thead>
<tbody><tr>
<td>优化器</td>
<td>优化查询计划：通过规则或代价模型，将逻辑计划转换为更高效的物理计划。</td>
</tr>
<tr>
<td>执行器</td>
<td>执行物理计划：按照优化后的物理计划，通过具体算法（如哈希聚合、索引扫描）操作底层数据。</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-操作对象不同"><a href="#2-操作对象不同" class="headerlink" title="2. 操作对象不同"></a>2. 操作对象不同</h3><table>
<thead>
<tr>
<th>组件</th>
<th>操作对象</th>
</tr>
</thead>
<tbody><tr>
<td>优化器</td>
<td>计划树（Plan Tree）：处理逻辑计划到物理计划的转换（如 <code>SeqScan</code>​ → <code>IndexScan</code>​）。</td>
</tr>
<tr>
<td>执行器</td>
<td>数据流（Data Stream）：处理实际元组的读取、过滤、聚合（如遍历 <code>TableHeap</code>​ 中的元组）。</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-阶段不同"><a href="#3-阶段不同" class="headerlink" title="3. 阶段不同"></a>3. 阶段不同</h3><table>
<thead>
<tr>
<th>组件</th>
<th>阶段</th>
</tr>
</thead>
<tbody><tr>
<td>优化器</td>
<td>查询编译阶段：在查询执行前完成，通过静态分析优化计划（如检查索引是否存在）。</td>
</tr>
<tr>
<td>执行器</td>
<td>查询执行阶段：在运行时动态处理数据（如遍历哈希表或索引结构）。</td>
</tr>
</tbody></table>
<hr>
<h3 id="4-策略差异"><a href="#4-策略差异" class="headerlink" title="4. 策略差异"></a>4. 策略差异</h3><h4 id="1-优化器（以-OptimizeSeqScanAsIndexScan​-为例）"><a href="#1-优化器（以-OptimizeSeqScanAsIndexScan​-为例）" class="headerlink" title="(1) 优化器（以 OptimizeSeqScanAsIndexScan​ 为例）"></a>(1) 优化器（以 <code>OptimizeSeqScanAsIndexScan</code>​ 为例）</h4><ul>
<li><p>规则驱动：根据预定义的规则（如“等值条件可替换为索引扫描”）转换计划。</p>
</li>
<li><p>代码片段分析：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (optimized_plan-&gt;<span class="built_in">GetType</span>() == PlanType::SeqScan) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> &amp;seq_plan = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> SeqScanPlanNode &amp;&gt;(*optimized_plan);</span><br><span class="line">  <span class="keyword">if</span> (seq_plan.filter_predicate_ 的比较类型是等值比较) &#123;</span><br><span class="line">    检查表是否有索引 → 替换为 IndexScanPlanNode</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>静态分析：通过目录（<code>catalog_</code>​）检查表的索引信息，不涉及实际数据操作。</li>
<li>计划替换：生成新的 <code>IndexScanPlanNode</code>​，但不会实际执行扫描。</li>
</ul>
</li>
</ul>
<h4 id="2-执行器（以-AggregationExecutor​-为例）"><a href="#2-执行器（以-AggregationExecutor​-为例）" class="headerlink" title="(2) 执行器（以 AggregationExecutor​ 为例）"></a>(2) 执行器（以 <code>AggregationExecutor</code>​ 为例）</h4><ul>
<li><p>数据驱动：直接操作数据流，依赖具体算法（如哈希聚合）计算结果。</p>
</li>
<li><p>代码片段分析：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AggregationExecutor::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (child_executor_-&gt;<span class="built_in">Next</span>(&amp;tuple_)) &#123;</span><br><span class="line">    aht_.<span class="built_in">InsertCombine</span>(key, value);  <span class="comment">// 实际处理数据并聚合</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>动态处理：在 <code>Init()</code>​ 阶段遍历子执行器的所有输入元组，构建哈希表。</li>
<li>结果生成：在 <code>Next()</code>​ 阶段遍历哈希表，返回聚合后的元组。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-依赖资源不同"><a href="#5-依赖资源不同" class="headerlink" title="5. 依赖资源不同"></a>5. 依赖资源不同</h3><table>
<thead>
<tr>
<th>组件</th>
<th>依赖资源</th>
</tr>
</thead>
<tbody><tr>
<td>优化器</td>
<td>目录（Catalog）：检查表结构、索引信息。<br /> 统计信息：代价模型可能需要表大小等数据。</td>
</tr>
<tr>
<td>执行器</td>
<td>缓冲池（BufferPool）：加载数据页。<br /> 事务（Transaction）：管理锁和日志。</td>
</tr>
</tbody></table>
<hr>
<h3 id="6-协作流程对比"><a href="#6-协作流程对比" class="headerlink" title="6. 协作流程对比"></a>6. 协作流程对比</h3><h4 id="优化器的典型流程"><a href="#优化器的典型流程" class="headerlink" title="优化器的典型流程"></a>优化器的典型流程</h4><ol>
<li><p>输入：绑定后的逻辑计划树（带表&#x2F;列元数据）。</p>
</li>
<li><p>操作：</p>
<ul>
<li>应用优化规则（如谓词下推、索引替换）。</li>
<li>生成物理计划（如将 <code>SeqScan</code>​ 替换为 <code>IndexScan</code>​）。</li>
</ul>
</li>
<li><p>输出：优化后的物理计划树。</p>
</li>
</ol>
<h4 id="执行器的典型流程"><a href="#执行器的典型流程" class="headerlink" title="执行器的典型流程"></a>执行器的典型流程</h4><ol>
<li><p>输入：物理计划树（如 <code>IndexScanPlanNode</code>​）。</p>
</li>
<li><p>操作：</p>
<ul>
<li>初始化执行器（如加载索引结构）。</li>
<li>通过 <code>Next()</code>​ 逐个返回结果元组。</li>
</ul>
</li>
<li><p>输出：最终查询结果。</p>
</li>
</ol>
<hr>
<h3 id="总结：优化器-vs-执行器"><a href="#总结：优化器-vs-执行器" class="headerlink" title="总结：优化器 vs. 执行器"></a>总结：优化器 vs. 执行器</h3><table>
<thead>
<tr>
<th>维度</th>
<th>优化器</th>
<th>执行器</th>
</tr>
</thead>
<tbody><tr>
<td>目标</td>
<td>生成高效执行计划</td>
<td>执行具体数据操作</td>
</tr>
<tr>
<td>操作对象</td>
<td>计划树（逻辑&#x2F;物理）</td>
<td>数据流（元组）</td>
</tr>
<tr>
<td>阶段</td>
<td>查询编译阶段（静态）</td>
<td>查询执行阶段（动态）</td>
</tr>
<tr>
<td>策略</td>
<td>规则驱动（如索引替换）、代价模型</td>
<td>算法驱动（如哈希聚合、索引遍历）</td>
</tr>
<tr>
<td>依赖资源</td>
<td>目录、统计信息</td>
<td>缓冲池、事务</td>
</tr>
<tr>
<td>代码特点</td>
<td>递归遍历计划树、条件匹配、生成新计划</td>
<td>迭代处理数据、状态管理（如哈希表迭代器）</td>
</tr>
</tbody></table>
<p>优化器决定“如何高效获取数据”，执行器负责“实际获取数据”。二者分工明确，共同实现高效查询。</p>
<p>‍</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://jyjays.github.io">Jyjays</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://jyjays.github.io/2025/02/21/Project%203%20Query%20Execution/Project%203%20Query%20Execution/">https://jyjays.github.io/2025/02/21/Project%203%20Query%20Execution/Project%203%20Query%20Execution/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Database/">Database</a><a class="post-meta__tags" href="/tags/CMU-15-445/">CMU 15-445</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2025/02/15/fuHwdPDZ8cNslFC.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/02/28/Project2%20Index.md/Project2%20Index/Project#2%20Extendible%20Hash%20Index/"><img class="prev-cover" src="https://s2.loli.net/2025/02/15/fuHwdPDZ8cNslFC.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Extendible Hash Index</div></div></a></div><div class="next-post pull-right"><a href="/2025/02/15/MIT%206.5840/KVRaft%20server/"><img class="next-cover" src="https://s2.loli.net/2025/02/15/fuHwdPDZ8cNslFC.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">KVRaft server</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2024/10/11/Query%20Processing/Query%20Processing/" title="Query Processing"><img class="cover" src="https://s2.loli.net/2025/02/15/fuHwdPDZ8cNslFC.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-10</div><div class="title">Query Processing</div></div></a></div><div><a href="/2024/09/05/Hash%20Tables/Hash%20Tables/" title="Hash Tables"><img class="cover" src="https://s2.loli.net/2025/02/15/fuHwdPDZ8cNslFC.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-04</div><div class="title">Hash Tables</div></div></a></div><div><a href="/2024/09/04/Buffer%20Pool/buffer%20pool/" title="Buffer Pool"><img class="cover" src="https://s2.loli.net/2025/02/15/fuHwdPDZ8cNslFC.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-03</div><div class="title">Buffer Pool</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2025/02/15/Yhj9w85grSxptQT.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Jyjays</div><div class="author-info__description">A CS learner who is interested in DataBase System and Music.</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Task-2"><span class="toc-number">1.</span> <span class="toc-text">Task #2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#aggregation-executor"><span class="toc-number">1.1.</span> <span class="toc-text">aggregation executor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nested-loop-join-executor"><span class="toc-number">1.2.</span> <span class="toc-text">nested loop join executor</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Task-3"><span class="toc-number">2.</span> <span class="toc-text">Task #3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash-Join-Executor"><span class="toc-number">2.1.</span> <span class="toc-text">Hash Join Executor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash-Join-algorithm"><span class="toc-number">2.1.1.</span> <span class="toc-text">Hash Join algorithm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Basic-Hash-Join"><span class="toc-number">2.1.2.</span> <span class="toc-text">Basic Hash Join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Grace-Hash-Join-Partitioned-Hash-Join"><span class="toc-number">2.1.3.</span> <span class="toc-text">Grace Hash Join &#x2F; Partitioned Hash Join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Implement"><span class="toc-number">2.1.4.</span> <span class="toc-text">Implement</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash-Join-Optimizer"><span class="toc-number">2.2.</span> <span class="toc-text">Hash Join Optimizer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Task-4"><span class="toc-number">3.</span> <span class="toc-text">Task #4</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Sort"><span class="toc-number">3.1.</span> <span class="toc-text">Sort</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-Top-N-Sort"><span class="toc-number">3.1.1.</span> <span class="toc-text">如何实现 Top-N Sort</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">1. 算法思想</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Window-Function"><span class="toc-number">3.2.</span> <span class="toc-text">Window Function</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Optimizer-%E5%92%8C-Executor-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.</span> <span class="toc-text">Optimizer 和 Executor 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%9B%AE%E6%A0%87%E4%B8%8D%E5%90%8C"><span class="toc-number">4.0.1.</span> <span class="toc-text">1. 目标不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1%E4%B8%8D%E5%90%8C"><span class="toc-number">4.0.2.</span> <span class="toc-text">2. 操作对象不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%98%B6%E6%AE%B5%E4%B8%8D%E5%90%8C"><span class="toc-number">4.0.3.</span> <span class="toc-text">3. 阶段不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%AD%96%E7%95%A5%E5%B7%AE%E5%BC%82"><span class="toc-number">4.0.4.</span> <span class="toc-text">4. 策略差异</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BC%98%E5%8C%96%E5%99%A8%EF%BC%88%E4%BB%A5-OptimizeSeqScanAsIndexScan%E2%80%8B-%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">4.0.4.1.</span> <span class="toc-text">(1) 优化器（以 OptimizeSeqScanAsIndexScan​ 为例）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%89%A7%E8%A1%8C%E5%99%A8%EF%BC%88%E4%BB%A5-AggregationExecutor%E2%80%8B-%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">4.0.4.2.</span> <span class="toc-text">(2) 执行器（以 AggregationExecutor​ 为例）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BE%9D%E8%B5%96%E8%B5%84%E6%BA%90%E4%B8%8D%E5%90%8C"><span class="toc-number">4.0.5.</span> <span class="toc-text">5. 依赖资源不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%8D%8F%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%AF%B9%E6%AF%94"><span class="toc-number">4.0.6.</span> <span class="toc-text">6. 协作流程对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%99%A8%E7%9A%84%E5%85%B8%E5%9E%8B%E6%B5%81%E7%A8%8B"><span class="toc-number">4.0.6.1.</span> <span class="toc-text">优化器的典型流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%99%A8%E7%9A%84%E5%85%B8%E5%9E%8B%E6%B5%81%E7%A8%8B"><span class="toc-number">4.0.6.2.</span> <span class="toc-text">执行器的典型流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A%E4%BC%98%E5%8C%96%E5%99%A8-vs-%E6%89%A7%E8%A1%8C%E5%99%A8"><span class="toc-number">4.0.7.</span> <span class="toc-text">总结：优化器 vs. 执行器</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/30/MIT%206.5840/ShardKV/ShardKV%20review/" title="ShardKV Review"><img src="https://s2.loli.net/2025/02/15/fuHwdPDZ8cNslFC.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ShardKV Review"/></a><div class="content"><a class="title" href="/2025/03/30/MIT%206.5840/ShardKV/ShardKV%20review/" title="ShardKV Review">ShardKV Review</a><time datetime="2025-03-30T08:00:00.000Z" title="Created 2025-03-30 00:00:00">2025-03-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/28/Query%20Execution%20+%20MVCC/Project%204%20Concurrency%20Control/" title="Project 4 Concurrency Control"><img src="https://s2.loli.net/2025/02/15/fuHwdPDZ8cNslFC.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Project 4 Concurrency Control"/></a><div class="content"><a class="title" href="/2025/03/28/Query%20Execution%20+%20MVCC/Project%204%20Concurrency%20Control/" title="Project 4 Concurrency Control">Project 4 Concurrency Control</a><time datetime="2025-03-28T08:00:00.000Z" title="Created 2025-03-28 00:00:00">2025-03-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/28/Query%20Execution%20+%20MVCC/Project%203%20Query%20Execution/Bustub%20Query%20Execution%E5%9B%9E%E9%A1%BE/" title="Bustub Query Execution回顾"><img src="https://s2.loli.net/2025/02/15/fuHwdPDZ8cNslFC.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Bustub Query Execution回顾"/></a><div class="content"><a class="title" href="/2025/03/28/Query%20Execution%20+%20MVCC/Project%203%20Query%20Execution/Bustub%20Query%20Execution%E5%9B%9E%E9%A1%BE/" title="Bustub Query Execution回顾">Bustub Query Execution回顾</a><time datetime="2025-03-28T08:00:00.000Z" title="Created 2025-03-28 00:00:00">2025-03-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/08/Project2%20Index.md/Project2%20Index/B+%20Tree%20questions/" title="B+ Tree questions"><img src="https://s2.loli.net/2025/02/15/fuHwdPDZ8cNslFC.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="B+ Tree questions"/></a><div class="content"><a class="title" href="/2025/03/08/Project2%20Index.md/Project2%20Index/B+%20Tree%20questions/" title="B+ Tree questions">B+ Tree questions</a><time datetime="2025-03-08T08:00:00.000Z" title="Created 2025-03-08 00:00:00">2025-03-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/28/Project2%20Index.md/Project2%20Index/B+%20Tree/" title="B+ Tree"><img src="https://s2.loli.net/2025/02/15/fuHwdPDZ8cNslFC.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="B+ Tree"/></a><div class="content"><a class="title" href="/2025/02/28/Project2%20Index.md/Project2%20Index/B+%20Tree/" title="B+ Tree">B+ Tree</a><time datetime="2025-02-28T08:00:00.000Z" title="Created 2025-02-28 00:00:00">2025-02-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Jyjays</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>